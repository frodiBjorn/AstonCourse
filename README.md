## Question 1

---

1. **Принцип KISS (Keep It Simple, Stupid)**:
   Принцип KISS гласит, что код должен быть максимально простым. Это означает, что код должен быть понятным, легко читаемым и поддерживаемым. Избегайте излишней сложности и избыточности в коде. Простота помогает снизить вероятность ошибок, упрощает отладку и улучшает понимание кода другими разработчиками.

2. **Принцип DRY (Don't Repeat Yourself)**:
   Принцип DRY гласит, что каждая часть логики должна иметь единственное представление в системе. Избегайте дублирования кода или информации. Вместо этого, вынесите общую функциональность в отдельные модули, функции или классы, чтобы избежать повторений.

3. **Принцип YAGNI (You Ain't Gonna Need It)**:
   Принцип YAGNI гласит, что не следует добавлять функциональность, которая в данный момент не требуется. Избегайте написания кода, который не используется или не требуется текущими требованиями. Добавление ненужной функциональности усложняет код, создает дополнительные возможности для ошибок и увеличивает сложность его поддержки.

### **Антипаттерны**

- **Спагетти-код** - код без структуры, модулей
- **Золотой-молоток** - неэффективное использование одного подхода, инструмента, под все задачи
- **Лодочный якорь** - когда оставляют код неиспользуемого кода, потому что он может понадобиться позже
- **Мертвый код** - когда оставляют код, который уже не работает, в текущей конфигурации
- **Разрастание кода** - когда в кодовой базе есть объекты, существующие исключительно для вызова других, более важных объектов
- **Божественный объект** - когда в вашей кодовой базе повсеместно требуется доступ к одному объекту и он делает слишком много
- **Магические числа** - это использование чисел напрямую в коде, без объяснения их значения

---

## Question 2

---

1. **LocalStorage**:

- Хранит данные без срока истечения действия.
- Вместимость составляет около 5 МБ.
- Данные доступны после закрытия браузера и повторного открытия.
- API: localStorage.setItem(key, value) , localStorage.getItem(key) , localStorage.removeItem(key) и т.д.

2. **SessionStorage**:

- Хранит данные до закрытия вкладки или окна браузера.
- Вместимость составляет около 5 МБ.
- Данные не доступны в других вкладках или окнах.
- API: sessionStorage.setItem(key, value) , sessionStorage.getItem(key) , sessionStorage.removeItem(key) и т.д.

3. **Cookie**:

- Хранит данные в виде пар ключ-значение.
- Имеет срок действия, который можно установить.
- Вместимость составляет около 4 КБ.
- Данные отправляются на сервер при каждом запросе.
- API: document.cookie = "key=value; expires=дата; path=путь" и т.д.

---

## Question 3

---

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Заголовок страницы</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <!-- Ваш контент здесь -->
    <script src="script.js"></script>
  </body>
</html>
```

- `<!DOCTYPE html>` : Объявление типа документа.
- `<html lang="ru">` : Открывающий тег для корневого элемента HTML, где lang="ru" указывает на русский язык.
- `<head>` : Содержит метаинформацию о документе, такую как кодировка, заголовок страницы и подключение стилей и скриптов.
- `<meta charset="UTF-8">` : Устанавливает кодировку документа.
- `<meta name="viewport" content="width=device-width, initial-scale=1.0">` : Определяет настройки отображения на мобильных устройствах.
- `<title>Заголовок страницы</title>` : Заголовок страницы, отображается во вкладке браузера или при поиске страницы.
- `<link rel="stylesheet" href="styles.css">` : Подключение внешнего файла стилей CSS.
- `<body>` : Основное содержимое страницы.
- `<script src="script.js"></script>` : Подключение внешнего файла скрипта JavaScript.

### **БЭМ**

БЭМ (Блок-Элемент-Модификатор) - это методология именования классов в HTML и CSS для создания модульной и масштабируемой архитектуры веб-приложений. Она помогает разделить структуру и стили компонентов, делая код более понятным и легко поддерживаемым.

```html
<div class="block">
  <div class="block__element">
    <div class="block__element--modifier"></div>
  </div>
</div>
```

- `.block` : Блок, основной компонент.
- `.block__element` : Элемент, составная часть блока.
- `.block__element--modifier` : Модификатор, изменение внешнего вида или поведения элемента.

---

## Question 4

---

Паттерны функционального программирования - это методология, основанная на функциях первого класса и неизменяемых данных. Она стремится к созданию программного кода, который является модульным, легко читаемым и поддерживаемым.

1. Чистые функции (Pure Functions): Это функции, которые возвращают результат только на основе своих входных аргументов, без побочных эффектов. Они не изменяют состояние программы и всегда возвращают одинаковый результат для одинаковых входных данных.

```js
function add(a, b) {
  return a + b;
}
```

2. Функции высшего порядка (Higher-Order Functions) - это функции, которые могут принимать другие функции в качестве аргументов или возвращать их в качестве результата.

```js
function multiplyBy(factor) {
  return function (number) {
    return number * factor;
  };
}

const multiplyBy2 = multiplyBy(2);
const multiplyBy5 = multiplyBy(5);

console.log(multiplyBy2(4)); // 8
console.log(multiplyBy5(3)); // 15
```

3. Неизменяемость (Immutability): Это принцип, согласно которому данные не могут быть изменены после создания. Вместо этого создаются новые данные при необходимости.

```js
const numbers = [1, 2, 3];
const newNumbers = [...numbers, 4]; // создание нового массива с добавленным элементом
```

4. Композиция функций (Function Composition): Это процесс создания новых функций путем комбинирования нескольких существующих функций.

```js
const multiplyBy2 = (x) => x * 2;
const add5 = (x) => x + 5;

const result = add5(multiplyBy2(3)); // 11
```

5. Каррирование (Currying): Это процесс преобразования функции с несколькими аргументами в последовательность функций с одним аргументом.

```js
const add = (a) => (b) => a + b;
const add5 = add(5);

const result = add5(3); // 8
```

6. Рекурсия (Recursion): Это процесс вызова функцией самой себя. Рекурсия позволяет решать задачи, которые могут быть разбиты на более простые подзадачи.

```js
function factorial(n) {
  if (n === 0) return 1;
  return n * factorial(n - 1);
}

const result = factorial(5); // 120
```

---

## Question 5

---

Способы позиционирования контента на странице:

1. Использование CSS свойства position : С помощью свойства position можно задавать позицию элемента на странице.

   - **static** (позиция по умолчанию)
   - **relative** (относительное позиционирование)
   - **absolute** (абсолютное позиционирование)
   - **fixed** (фиксированное позиционирование)
   - **sticky** (позиционирование с учетом прокрутки).

2. Использование CSS свойств **top** , **bottom** , **left** и **right** : Эти свойства используются совместно с position для определения конкретной позиции элемента на странице.

3. Использование CSS Flexbox: Flexbox - гибкий способ управления расположением элементов в контейнере. С помощью свойств, таких как **display: flex**, **flex-direction**, **justify-content** и **align-items**, можно легко управлять расположением элементов внутри контейнера.

4. Использование CSS Grid: CSS Grid - способ создания сетки элементов на странице. С помощью свойств, таких как **display: grid** , **grid-template-columns** и **grid-template-rows** , можно создать гибкую сетку элементов.

5. Использование CSS позиционирования с помощью селекторов классов и идентификаторов с помощью CSS свойств, таких как **margin**, **padding** и **float** .

---

## Question 6

---

В CSS вес селекторов (специфичность) определяет, какой стиль будет применен к элементу, когда есть несколько правил, которые срабатывают на него одновременно. Вес селектора измеряется числом и определяется на основе типа селектора и количества его компонентов.

Селекторы по весу:

1. inline стили (те которые мы пишем внутри атрибута style для тега) `<div style = "color"></div>` - специфичность 1,0,0,0

2. Селектор идентификатора `#id` - специфичность 0,1,0,0

3. Селектор класса `.class` - специфичность 0,0,1,0

4. Селектор атрибутов `[type="radio"]` - специфичность 0,0,1,0

5. Селектор псевдоклассов `li:first-child` - специфичность 0,0,1,0

6. Селектор тэгов `div` - специфичность 0,0,0,1

7. Селектор псевдоэлементов `li:after` - специфичность 0,0,0,1

8. Универсальный селектор `*` - специфичность 0,0,0,0

Когда при объявлении стиля используется модификатор `!important`, это объявление получает наивысший приоритет среди всех прочих объявлений. Использовать его рекомендуется только в крайних случаях.

---
