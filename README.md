## Question 1

---

Метод OPTIONS используется, чтобы узнать какие методы запросов поддерживаются сервером.

Метод OPTIONS вызывается клиентом, когда он хочет узнать, какие методы запроса разрешены для конкретного ресурса или сервера.

OPTIONS может использоваться для разработки API, чтобы предоставить клиентам информацию о доступных функциях и методах запроса.

Запрос OPTIONS не передает никаких данных или тело запроса. Он высылает только заголовки запроса, которые могут содержать дополнительную информацию, такую как "Origin" для CORS или "Access-Control-Request-Method" для проверки таких аспектов, как политика доступа или разрешенные методы запроса.

Сервер возвращает ответ OPTIONS с заголовками, которые указывают на доступные методы запроса. Это может быть заголовок "Allow", который содержит список разрешенных методов запроса, или заголовок "Access-Control-Allow-Methods" для указания методов, разрешенных для CORS.

Пример:

Запрос

```
OPTIONS /api/users HTTP/1.1
Host: example.com
```

Ответ

```
HTTP/1.1 200 OK
Allow: GET, POST, PUT, DELETE
```

---

## Question 2

---

HTTP 3.0 - новая версия протокола передачи данных в сети. Он был разработан для улучшения производительности и безопасности передачи данных по сравнению с предыдущей версией HTTP/2. Одной из ключевых особенностей HTTP/3 является его основа на протоколе передачи данных QUIC. Вместо использования TCP для установки соединения, QUIC использует UDP. Это позволяет уменьшить задержку и повысить производительность передачи данных.

HTTP 3.0 включает в себя мультиплексирование, что позволяет одновременно передавать несколько запросов и ответов по одному соединению. Это улучшает эффективность использования сети и уменьшает задержку при передаче данных.

TCP - **надёжный, медленный (требуется проверка целостности, обмен рукопожатиями)**

UDP - **не надёжный, быстрый (пакеты передаются сразу)**

QUIC - **решает проблемы обоих протоколов:**

- Сокращает время на установку соединения
- Берёт от UDP высокую скорость передачи, но при этом контролирует целостность пакетов.
- Мультиплексирование - может передавать несколько пакетов параллельно, что тоже ускоряет их доставку.
- Шифрование по умолчанию.

---

## Question 3

---

В основном для отмены запроса используется AbortController. Этот способ пришёл на смену CancelToken в Axios.

AbortController — это собственный объект контроллера JavaScript. AbortController содержит экземпляр объекта signal. Это позволяет взаимодействовать с запросом DOM или HTTP и прерывать его при вызове метода abort().

Можно использовать в fetch или Axios

Пример для Axios:

```js
const abortController = new AbortController();

axios
  .get("https://your-server.com/products", {
    signal: abortController.signal,
  })
  .catch(function (e) {
    if (axios.isCancel(e)) {
      console.error("Operation canceled");
    } else {
    }
  });
abortController.abort();
```

Также отменять запрос можно если используется XMLHttpRequest, через метод abort()

```js
const xhr = new XMLHttpRequest();
xhr.open("GET", "/1.json");
xhr.send();

setTimeout(() => {
  xhr.abort();
}, 1000);
```
---

## Question 4

---
 **String**
 - Использование двойных кавычек: 
    ```js
    let message = "Hello"
    ```
- Использование одинарных кавычек: 
    ```js
    let message2 = 'World'
    ```
- Использование обратных кавычек: 
    ```js
    let phrase = `${message} World`
    ```
- Конструктор String:
    ```js
    let str = new String("JavaScript")
    ```
- Метод toString():
    ```js
    let myNumber = 10
    let myString = myNumber.toString()
    ```
- Метод String():
    ```js
    let myNumber2 = 20
    let myString2 = String(myNumber2)
    ```

 **Number**
 - Использование целых чисел: 
    ```js
    let integer = 42
    ```
  - Использование чисел с плавающей точкой: 
    ```js
    let float = 9.99
    ```
  - Использование чисел в экспоненциальной форме: 
    ```js
    let expNumber = 2.e3 //2000
    ```
  - Конструктор Number: 
    ```js
    let num = new Number(42)
    ```
  - Преобразование строк в число: 
    ```js
    let num2 = parseInt("10")
    let num3 = parseFloat("3.14")
    let num4 = +'999'
    ```
  - Метод Number: 
    ```js
    let num5 = Number('5')
    ```
 **Boolean**
 - Явное присвоение true или false: 
    ```js
    let isReady = true
    ```
  - Использование результата сравнений: 
    ```js
    let isGreater = 4 > 1
    ```
  - Двойное отрицание:
    ```js
    let isBoolean = !!6
    ```
  - Преобразование с помощью функции Boolean():
    ```js
    let falseBoolean = Boolean(''); // false
    let trueBoolean = Boolean(10); // true
    ```
 **Null**
 - Использование присвоения значения: 
    ```js
    let emptyVariable = null
    ```
  - Использование явного присваивания: 
    ```js
    let emptyVariable2
    emptyVariable2 = null
    ```
 **Undefined**
 - Использование переменной без значения: 
    ```js
    let age
    ```
 - Использование присвоения значения: 
    ```js
    let undefinedValue = undefined
    ```
  - Использование неопределенного результата выполнения функции: 
    ```js
    function myFunction() {}
    let result = myFunction();
    ```
 **Symbol**
 - Cоздание нового символа: 
    ```js
     let id = Symbol()
    ```
  - Создание символа с описанием: 
    ```js
    let id = Symbol("id")
    ```
  - Использование глобальных символов:
    ```js
    let symbol = Symbol.for("Name");
    ```
 **BigInt**
 - Добавление n в конец числового литерала: 
    ```js
      let bigNumber = 9007199254740991n
    ```
  - Использование функции BigInt: 
    ```js
    const sameBigint = BigInt("1234567890123456789012345678901234567890")
    ```
---

## Question 5

---
При объявлении переменных с помощью ключевых слов let и const, создается так называемая "временная мертвая зона" (temporal dead zone). В этой зоне переменные уже существуют, но им не присвоены значения и их нельзя использовать. В результате, при попытке обратиться к таким переменным до их объявления, возникает ReferenceError. Это сделано для того, чтобы избежать ошибок, связанных с неопределенными значениями переменных.

---

## Question 6

---
```js
const res = "B" + "a" + (1 - "hello");
console.log(res); 
```
Сначала вычисляется выражение `(1 - "hello")`, что даст NaN, так как попытка вычесть строку из числа возвращает NaN.

Далее выполняется конкатенация строк `"B"` и  `"a"`.

В конце NaN приводится к строке и склеивается, что в результате даёт строку:
```
BaNaN
```
---
```js
const res2 = (true && 3) + "d";
console.log(res2);
```
Сначала вычисляется выражение `(true && 3)`,используется логическое "и" (`&&`), оно возвращает первый false значение или последнее true, как в данном случае, вернётся число `3`.

Далее, полученное число `3` конкатенируется со строкой `"d"` оператором `+`. Конкатенация двух значений превращает число в строку.

Таким образом, результатом выполнения выражения будет строка `"3d"`.

---
```js
const res3 = Boolean(true && 3) + "d";
console.log(res3);
```
Сначала вычисляется выражение `(true && 3)`,используется логическое "и" (`&&`), оно возвращает первый false значение или последнее true, как в данном случае, вернётся число 3.

Затем, значение `3` приводится к логическому типу данных с помощью функции `Boolean()`. В результате получается логическое значение `true`.

Далее, значение `true` конкатенируется со строкой `"d"`, используя оператор `+`.


Таким образом, результатом выражения будет строка `"trued"`.